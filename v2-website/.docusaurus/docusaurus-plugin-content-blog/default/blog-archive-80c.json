{
  "blogPosts": [
    {
      "id": "/2022/08/31/comby-with-types",
      "metadata": {
        "permalink": "/blog/2022/08/31/comby-with-types",
        "source": "@site/blog/2022-08-31-comby-with-types.md",
        "title": "Find and replace with type information",
        "description": "table td {",
        "date": "2022-08-31T00:00:00.000Z",
        "formattedDate": "August 31, 2022",
        "tags": [],
        "readingTime": 15.895,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Rijnard",
            "url": "https://twitter.com/rvtond",
            "imageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
          }
        ],
        "frontMatter": {
          "id": "comby-with-types",
          "title": "Find and replace with type information",
          "author": "Rijnard",
          "authorURL": "https://twitter.com/rvtond",
          "authorImageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
        },
        "nextItem": {
          "title": "Deconstructing programs for compiler fuzzing",
          "permalink": "/blog/2022/04/11/comby-decomposer-compiler-fuzzing"
        }
      },
      "content": "<style>\ntable td {\n   padding: 0px;\n   border: none;\n}\ntable tr {\n   padding: 0px;\n   border: none;\n}\nblockquote {\n#   text-align: center;\n    background: white;\n    border: 2px solid rgba(1, 1, 1, .1);\n    border-radius: 10px;\n    border-top: 0px;\n    border-bottom: 0px;\n#    border-right: 0px;\n#    border-left: 0px;\n}\n\nul {\n\tlist-style-type: none;\n}\nli {\n  list-style-type: none;\n}\n</style>\n\n> Eventually the realization will hit that you're just trying to approximate what a compiler\nusually does, but with a regex pattern [...] and all you really wanted was type information.\n\nOne of the earliest code changes I made with `comby` removed redundant code in\nthe Go compiler. After proposing changes, I soon came to the sad realization\nthat some of them turned out to be just plain wrong.<sup>[1](#footnotes)</sup> What I missed is that a\nvalue's **type** could affect whether the code was really redundant or not.\n\nThe mechanical, syntactic change removes a redundant `nil` check and goes like this:\n\n**Before**\n```go\nif x != nil {\n  for ... := range x {\n    ...\n  }\n}\n```\n\n**After**\n```go\nfor ... := range x {\n  ...\n}\n```\n\nThe tricky bit is that this change is only valid if `x` is a slice or map, and\nnot if `x` is a pointer or channel.<sup>[2](#footnotes)</sup> If we only have the syntax to go on, there\nreally is no way to know if the change is valid. Ever since then I've\nwanted a way to pull type information into `comby`. \n\nThere's now an experimental way to query type information with\n`comby` that solves this kind of issue. The main idea is to write [a rule](../../../../docs/advanced-usage#rules) that pattern matches against\ntype information in hover tool tips (i.e., type-on-hover data).\n\n```bash\nwhere match :[x].lsif.hover {\n  | ... map... -> true\n  | ... []... -> true\n  | _ -> false\n}\n```\n\nThis kind of rule gives enough flexibility to avoid false positives, filtering\nand changing only code where type-on-hover suggests we have a slice (like\n`[]string` syntax in Go) or map (like `map[string]string)` on our hands.\n\nA few things need to fall in place for this to work, and only a couple of\nopen source projects and languages are supported right now. It's meant to be an\nearly interface, implemented to generically support future language and project\nexpansions. Read on to learn what's possible at the frontier of simpler find\nand replace _with types_.\n\n## Extending `comby` with type information\n\nWhen I think about adding type information to `comby` I want to keep things\nsimple and easy. Anything too heavyweight isn't a good fit, because\nlanguage-specific tools exist for automating complex changes to the nth degree\n(`clang` for C) and I don't have time to integrate or maintain such toolchains directly\nin `comby`. To that end, I really just want `comby` to use an external service\nthat answers: _What is the type of the value at this location in the file?_\n\nType-information-as-a-service is ideal because then I can keep the convenience\nof matching syntax easily, and outsource accessing language-specific semantic\nproperties as needed. The _concept_ is to expose a\n[property](../../../../docs/rewrite-properties) on any matched variable that corresponds to type\ninformation (if available). It might look something like this:\n\n```\nfunc parse(:[args]) where :[args].type == string\n```\n\nFor practical reasons, `:[args].type` would just be a simple string in `comby`.\nIn other words, it's just a string representation of a type (like what you'd\nsee in a hover tooltip). So, calling this a \"type\" property is a bit _too_\nsimplistic because in reality types are expressions. It isn't practical to\nrepresent types as such in `comby` today, which is why I've chosen to use a\ndifferent name `.lsif.hover` instead (more on this later).\nIncorporating more of the type system to accurately represent terms is welcome\ninformation, and perhaps one day `comby` will expose a more precise `.type`\nnotion. For now we can still make progress on the\nfind-and-replace-with-types problem in the leading example and many others.\nYou can [skip ahead to what this ends up looking like in `comby` today](#using-comby-with-types-today) but it might make more sense if I tell\nyou where I'm pulling the type information from first.\n\n\n\n## Where can I find type information as a service?\n\nI know of only two high-level solutions resembling a service that conveniently provides\ntype information today, and which aim to eventually support all languages. The\nfirst is language server implementations of LSP (Language Server Protocol).\nLanguage servers expose all kinds of information, and typically include type\ninformation in [hover tooltips](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_hover)\nfound in editors. With LSP there is no authoritative, centralized language server that you can\njust query.  Instead, language servers are configured for specific\nprojects and either run locally on your machine or get managed by an\norganization. \n\nThe second is a central, public-facing service maintained on\n[Sourcegraph.com](https://docs.sourcegraph.com/code_navigation/explanations/precise_code_navigation)\nthat exposes hover information similar to the LSP format (disclaimer: I work at\nSourcegraph, but my day job is unrelated to this service). The key difference\nis that Sourcegraph automatically processes popular repositories on GitHub\n(currently [about\n45K](https://about.sourcegraph.com/blog/announcing-scip#challenges-of-scaling-up-lsif))\nwith support for TypeScript, Go, Java, Scala, and Kotlin. It's also possible to\nprocess your own projects (locally, in CI, or GH actions) and upload the data.\nOnce that happens, you can efficently browse or query type information for\nvariables on hover.\n\n<img src=\"/img/hover.png\" alt=\"Hover information in Sourcegraph\">\n<!-- https://sourcegraph.com/github.com/sourcegraph/sourcegraph@d5948e24b6f709b9fdbf8e8f55d42b3e460e2f8d/-/blob/enterprise/cmd/frontend/internal/codeintel/resolvers/graphql/util.go?L123&subtree=true -->\n\nThis is exactly the kind of information I need to tell whether a matched\nvariable is a slice, map, channel, or pointer. For supported projects, you just\nfire a [GQL request](https://sourcegraph.com/api/console#%7B%22query%22%3A%22query%20Hover(%24repository%3A%20String!%2C%20%24commit%3A%20String!%2C%20%24path%3A%20String!%2C%20%24line%3A%20Int!%2C%20%24character%3A%20Int!)%20%7B%5Cn%20%20repository(name%3A%20%24repository)%20%7B%5Cn%20%20%20%20commit(rev%3A%20%24commit)%20%7B%5Cn%20%20%20%20%20%20blob(path%3A%20%24path)%20%7B%5Cn%20%20%20%20%20%20%20%20lsif%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20hover(line%3A%20%24line%2C%20character%3A%20%24character)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20markdown%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20text%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20range%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20start%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20line%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20character%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20end%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20line%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20character%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22operationName%22%3A%22Hover%22%2C%22variables%22%3A%22%7B%5Cn%20%20%5C%22repository%5C%22%3A%20%5C%22github.com%2Fsourcegraph%2Fsourcegraph%5C%22%2C%5Cn%20%20%5C%22commit%5C%22%3A%20%5C%22HEAD%5C%22%2C%5Cn%20%20%5C%22path%5C%22%3A%20%5C%22client%2Fshared%2Fsrc%2Fsearch%2Fquery%2Fparser.ts%5C%22%2C%5Cn%20%20%5C%22line%5C%22%3A%2074%2C%5Cn%20%20%5C%22character%5C%22%3A%209%5Cn%7D%22%7D) to get the hover content. \n\n<!--  curl 'https://sourcegraph.com/.api/graphql' --data-raw $'{\"query\":\"query Hover($repository: String!, $commit: String!, $path: String!, $line: Int!, $character: Int!) {\\\\n  repository(name: $repository) {\\\\n    commit(rev: $commit) {\\\\n      blob(path: $path) {\\\\n        lsif {\\\\n          hover(line: $line, character: $character) {\\\\n            markdown {\\\\n              text\\\\n            }\\\\n            range {\\\\n              start {\\\\n                line\\\\n                character\\\\n              }\\\\n              end {\\\\n                line\\\\n                character\\\\n              }\\\\n            }\\\\n          }\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n}\\\\n\",\"variables\":{\"repository\":\"github.com/sourcegraph/sourcegraph\",\"commit\":\"HEAD\",\"path\":\"client/shared/src/search/query/parser.ts\",\"line\":74,\"character\":9},\"operationName\":\"Hover\"}'  --compressed -->\n\nI went with this second option for two reasons.\n\n**Managing language servers is too difficult.** \nSome years ago I had a\nprototype where `comby` starts up language servers and queries them. It was a\npain to manage and configure servers, especially on various open source\nprojects. Although I succeeded at getting things up and running for about 5\nlanguages and various projects, I didn't like how brittle things were\nand discontinued the effort. In principle there's\nnothing stopping an ambitious developers to generically integrate `comby` with\nLSP (and even restrict it to one language or project). I just don't want to\nwrite or maintain that kind of thing.\n\n**Network requests to central services are easy.** Ultimately I implemented\ngeneric support in `comby` to pull hover information from any central service\nexposing type information over HTTP (less hassle for me), and the default\nservice with the best support for that right now is Sourcegraph.com.\n\n## Using `comby` with types today\n\nType information is accessed in code hovers via `:[x].lsif.hover`\nsyntax. This syntax resolves hover information at the end position of `:[x]` when\n`comby` succeeds at retrieving this information from an external service.\nUntil generic code intelligence services become more definitive, inspecting\nhover information is currently the most direct way to access type information\nfrom a central service today. \nThe `lsif` part is a reference to [LSIF](https://microsoft.github.io/language-server-protocol/overviews/lsif/overview/),\na schema related to LSP and [SCIP](https://about.sourcegraph.com/blog/announcing-scip#challenges-of-scaling-up-lsif).\n\n**Go example redux, this time without disappointment.** \nAdding [a rule](../../../../docs/advanced-usage#rules) to check type-on-hover information solves the false positive issues from before.\n\n```bash\nwhere match :[x].lsif.hover {\n  | ... map... -> true\n  | ... []... -> true\n  | _ -> false\n}\n```\n\nI settled on this rule based on the type-on-hover information I saw for\npotential matches in popular Go repositories. Here are some matches and\nnon-matches I found by using the new `:[x].lsif.hover` ability.\n\n✅ `struct field ExtraHeaders map[string]string` --- we want to match this, it's a `map`!\n\n<img src=\"/img/hover-rclone.png\" alt=\"Hover information in Sourcegraph for the rclone project\">\n\n- This is a file in `github.com/rclone/rclone`. [You can browse it and see the redundant `nil` check for yourself ↗](https://sourcegraph.com/github.com/rclone/rclone@35349657cd2d5708b2b02a8f8810270c4c999abb/-/blob/lib/rest/rest.go?L249-254&subtree=true)\n\n✅ `struct field ImportStateReturn []*InstanceState` --- we want to match this, it's a `[]` slice!\n- This is a redundant `nil` check in [`github.com/hashicorp/terraform`](https://sourcegraph.com/github.com/hashicorp/terraform@cb340207d8840f3d2bc5dab100a5813d1ea3122b/-/blob/internal/legacy/terraform/provider_mock.go?L293-294)\n\n❌ `var hashCh chan *blockTxHashes` --- we don't want to match this, its a channel type `chan`!\n- This valid `nil` check lives in [`github/ethereum/go-ethereum`](https://sourcegraph.com/github.com/ethereum/go-ethereum@d10c28030944d1c32febba3f45ae8c175ab34063/-/blob/core/rawdb/chain_iterator_test.go?L84-85&subtree=true)\n\nYou can use other patterns to achieve similar things, with deeper or looser\nprecision. For example, you could write a regex pattern to match undesired\ncases where the string contains `chan`, and then explicitly exclude such matches.\n\n- `| ...:[~\\bchan\\b]... -> false`\n\n<details>\n  <summary><strong>Expand to see the full command line invocation I ran on each project</strong></summary>\n\n<sup>You first need to clone each repository, change to the root directory, and can then\nrun this command if you have a recent version of comby. See\n[footnotes](#footnotes) if you want more info for running things yourself.<sup>\n\n```bash\nCOMBY_MATCH=\"$(cat <<\"MATCH\"\nif :[x] != nil {\n  for :[e] := range :[x] {\n    :[body]\n  }\n}\nMATCH\n)\"\nCOMBY_REWRITE=\"$(cat <<\"REWRITE\"\nfor :[e] := range :[x] {\n  :[body]\n}\nREWRITE\n)\"\nCOMBY_RULE=\"$(cat <<\"RULE\"\nwhere match :[x].lsif.hover {\n  | ... map... -> true\n  | ... []... -> true\n  | _ -> false\n}\nRULE\n)\"\ncomby \"$COMBY_MATCH\" \"$COMBY_REWRITE\" -rule \"$COMBY_RULE\" .go\n```\n\n<!--\n```bash\nCOMBY_MATCH=\"$(cat <<\"MATCH\"\nif :[x] != nil {\n  for :[e] := range :[x] {\n    :[body]\n  }\n}\nMATCH\n)\"\nCOMBY_REWRITE=\"$(cat <<\"REWRITE\"\nfor :[e] := range :[x] {\n  :[body]\n}\nREWRITE\n)\"\nCOMBY_RULE=\"$(cat <<\"RULE\"\nwhere match :[x].lsif.hover {\n  | ... map... -> true\n  | ... []... -> true\n  | _ -> false\n}\nRULE\n)\"\ncomby \"$COMBY_MATCH\" \"$COMBY_REWRITE\" -rule \"$COMBY_RULE\" -rg \"-g '*.go'\"\n```\n-->\n\n</details>\n\nThis behavior is admittedly an approximation to\nget type information. For example, `.lsif.hover` may also contain doc strings\nand matching may need to work around this extraneous data. But (I assert) it is often good\nenough for various type-sensitive changes. You can also use `:[x].lsif.hover`\nin the rewrite _output_.\n\nThis will let you inspect the information exposed\nby `:[x].lsif.hover`. In fact, that's exactly what I did to decide how to match on type information\nfor my rule. I just substituted it in a Go comment in the output.\n\n<img src=\"/img/hover-diff.png\" alt=\"Hover information substituted in output template\">\n\n<details>\n  <summary><strong>Expand to see sample match and rewrite templates for inspecting hover info</strong></summary>\n**Match**\n```go\nif :[x] != nil {\n  for :[e] := range :[x] {\n    :[body]\n  }\n}\n```\n\n**Rewrite**\n\n```go\nif :[x] != nil {\n  /* hover info is: :[x].lsif.hover */\n  for :[e] := range :[x] {\n    :[body]\n  }\n}\n```\n<!-- bit.ly/3e6zt3O -->\n\n</details>\n\n### Which projects and languages does this work for?\n\nIf a repository is processed with precise type-on-hover on Sourcegraph.com, accessing that information via\n`comby` should just work. This means you can use tools to process and upload\nthis information with your own\n[TypeScript](https://github.com/sourcegraph/scip-typescript), [Java, Scala,\nKotlin](https://github.com/sourcegraph/scip-java), or\n[Go](https://github.com/sourcegraph/lsif-go) projects to Sourcegraph and\n`comby` will be able to access hover information for them. \nThese tools encode type\ninformation and other data using\n[SCIP](https://about.sourcegraph.com/blog/announcing-scip#challenges-of-scaling-up-lsif),\nwhich is related to the Language Server Index Format\n([LSIF/LSP](https://microsoft.github.io/language-server-protocol/overviews/lsif/overview/))\nbut with efficiency in mind.\n\n\nIf you happen to work at a company with a running Sourcegraph instance that\nindexes any of these languages, you're in luck: setting\n`LSIF_SERVER=https://your-instance/.api/graphql` when you run `comby` will enable it to get\nhover information from your instance.<sup>[3](#footnotes)</sup> \n\nSee more at the end of the post if you want to try things out yourself.<sup>[4](#footnotes)</sup> \n\n## When is type information actually useful for find and replace?\n\nI've gotten this question a couple of times from my developer friends, and\noften they're able to nod their heads that accessing this kind of type\ninformation is theoretically useful, but they really want to see concrete\nexamples. The reality is that vast amounts of changes that simplify\nexpressions, modernize functions, or apply lint-like fixes require type\ninformation. \n\nThe connection might not be obvious because accessing type information is\ntypically buried deeper in a linter or compiler, after the initial layer of\nsyntax concerns (parsing), and tightly coupled to the language. So to give a\nsense, here are some diverse ways where explicitly pulling in type information\nsupercharges code search and refactoring.\n\n- **›** We've covered a Go example, which is a code simplification implemented in\n[`staticcheck`](https://staticcheck.io). Here are [many more code simplifications with the same flavor](https://staticcheck.io/docs/checks#S1)---the last time I counted, at\nleast 18 of the 35 checks require type information to ensure correctness.\n<!--https://gist.github.com/rvantonder/10b38eb3404d09312961af5a651524e80-->\n\n- **›** In Java, `try-catch-finally` blocks can be replaced with more succinct\n[`try-with-resources` blocks](https://www.baeldung.com/java-try-with-resources#overview)\nthat automatically close resources, like files. The catch? We need to know\nwhether an object implements the [`AutoCloseable`\ninterface](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html?is-external=true).\nThis also is type information we need to correctly refactor.\n\n- **›** Equality operators `==` on generic values can lead to Bad Things™. This is\na well-known pitfall in JavaScript and found in other languages too. See this\npost on the [\"perils of polymorphic compare\"](https://blog.janestreet.com/the-perils-of-polymorphic-compare/) in\nOCaml, and type coercion simplifications for Erlang in [Section 3.2 of this paper](https://users.ece.cmu.edu/~aavgerin/papers/Erlang09.pdf). In statically\ntyped languages like OCaml, you can use equality operators for a \nspecific type like `Int.equal` or `String.equal` instead. But when you look at an expression like\n`x == y`, how do you know if it's safe to replace the expression with something\nlike `Int.(x == y)` or `String.(x == y)` or something else? That's right, you\nneed something to tell you the type of `x` or `y`.\n\n- **›** Types make static analysis more precise and help remove false positives in bug\nreports. Analyzers like Semgrep and PMD include ways to reference type\ninformation for checks like [\"only report a potential SQL injection if the\nargument passed is of type string (`int` is safe)\"](https://r2c.dev/blog/2020/type-awareness-in-semantic-grep/#why-care-about-types) or [\"only report a violation if a loop index type is a `float`\"](https://pmd.sourceforge.io/pmd-6.11.0/pmd_rules_java_errorprone.html#dontusefloattypeforloopindices).\n\n- **›** Reducers like [`creduce`](https://github.com/csmith-project/creduce) and [`comby-reducer`](https://comby.dev/blog/2021/03/26/comby-reducer) automatically transform a program in _valid ways_ to produce smaller source code that triggers the same runtime behavior of the original. Reducers can use type information to more precisely guarantee valid programs, or use type information to make the program smaller. For example, `creduce` will remove the `&` operator in C code depending on the expression and its type ([see the complete description here](https://github.com/csmith-project/creduce/blob/6dc5a9d8e4b7e68d969a8c0dff59a7b46f083256/clang_delta/RemoveAddrTaken.cpp#L26-L32)).\n\nIn these examples, types can sometimes be inferred by matching on existing\nsyntax definitions, but things will quickly become intractable as you try to\nfollow the type propagation in and across functions. Eventually the realization\nwill hit that you're basically just trying to approximate what a compiler\nusually does, but with a regex pattern. Really all you want is for the\ninformation to exist, and a convenient way to look it up.\n\n## A more general view on integrating type information \n\n**I've long wanted an interface that effectively _decouples_ accessing general\nsemantic properties from patterns that match syntax.** This stems from the fact\nthat there's virtually no mature tools today where you can access deep semantic\nproperties _without_ needing to write code or interface with heavyweight\ntooling like `clang` (the exception might be IntelliJ structural\nsearch-and-replace). By deep I mean not just locally scoped type information\nor primitives. Although the `lsif.hover` data today is a string representation,\nit is a _deep_, project-global representation of the underlying type. As I've\ncontinued developing `comby` I've realized that it _just makes sense_ to\ndecouple language-general syntax pattern matching and language-specific\nsemantic properties. It works well to _compose_ syntax pattern matching and\ntype information for those _lightweight_ code changes or checks in the examples\nabove. \n\n**The leading thought is that semantic properties don't need to be restricted to\njust type information.** Precise \"rename symbol\" operations in editors (say, to\nrename a function and update its calls) rely on semantic relations over\ndefinitions and references to work. Similar to exposing type information,\n`comby` could also expose information and operations on \"all references for the\nsyntax matched at this point\" or resolve \"definitions for this matched syntax\".\nBecause `comby` is a more general syntactic rewriter than editor\nfind-and-replace prompts, these semantic properties could unlock easier ways to\ndo things like instrument code (e.g., add a debug statement after every\nreference) or selectively emit information to build domain-specific semantic\nlanguage models.\n\nThe idea of exposing semantic information alongside syntactic changes is not\nnew. The closest and most cogent discussion on this topic I've found uses an\napt term: _semantic selectors_. Unfortunately the paper is paywalled, but\nhere's an excerpt:\n\n> Program manipulation systems provide access to static semantic information through _semantic selectors_ which yield attributes associated with nodes.\nFor example, a manipulation system for a statically scoped language will supply a semantic selector that yields the _defining occurrence_ of a given name (i.e., the point\nwhere the name is defined).\n>\n> Language Design for Program Manipulation by Merks et al., IEEE Transactions on Software Engineering, 1992. [↗](https://ieeexplore.ieee.org/document/120313)\n\nStrikingly, tools today still don't expose semantic information like this\nwithout heaps of complexity and difficulty (think about installing and running\nlanguage-specific toolchains, or writing analyses using them). The current\ntrend of language-server-like tools is the closest effort to a simpler semantic\ninterface, but it is heavily influenced by code editor workflows. I'm hopeful\nfor an ecosystem with broader _semantic selectors as a service_ that expose deep\ninformation for all languages. Find and replace with types is one of\nthe best reasons I've found for doing that so far.\n\n---\n\n#### Footnotes\n\n<sup>1. [Original Go PR](https://go-review.googlesource.com/c/go/+/140998/)</sup> \n<br>\n<br>\n<sup>2. The underlying semantics for a `range` operation differs based on the type of\n`x`. When `x` is a `nil` slice or map, no check is needed, and the `range`\noperation is effectively a no-op (my guess is this behavior is probably\nimplemented for convenience). But when `x` is a pointer or channel, a missing\ncheck could lead to a null dereference or blocking, respectively.\n</sup>\n<br>\n<br>\n<sup>3. Please note nothing in this post is a Sourcegraph-endorsed\nor maintained feature, it's a personally maintained experimental feature in `comby` added by me, the author.</sup>\n<br>\n<br>\n<sup>4. Some quick usage notes if you decide to try the things in this post:\n<br>\n<sup>\n-&nbsp; **›**  You need to use the latest [docker distribution](https://github.com/comby-tools/comby#docker) or [build comby from source](https://github.com/comby-tools/comby#build-from-source). This because the latest version is not yet available to Linux or via `brew` on macOS.\n</sup>\n<br>\n<sup>\n&nbsp; **›**  You still need to clone the target repository locally (like `github.com/rclone/rclone`), then run `comby` at the root of the project.\n</sup>\n<br>\n<sup>\n&nbsp; **›** I'm not sure which projects are automatically indexed, but `comby` will\n  notify you if a `lsif.hover` property isn't available.\n</sup>\n<br>\n<sup>\n&nbsp; **›** For help with Sourcegraph stuff visit [their Discord](https://discord.gg/rDPqBejz93). For `comby` things visit the [gitter channel](https://gitter.im/comby-tools/community).\n</sup>\n<br>\n<sup>\n&nbsp; **›** Using `comby` to access hover info is experimental and subject to change.\n</sup>\n\n<!-- \ndocker run --platform linux/amd64 --rm -it --entrypoint sh comby/comby-rg:alpine-3.14-1.8.2   \n\nCOMBY_MATCH=\"$(cat <<\"MATCH\"\nif :[x] != nil {\n  for :[e] := range :[x] {\n    :[body]\n  }\n}\nMATCH\n)\"\nCOMBY_REWRITE=\"$(cat <<\"REWRITE\"\nfor :[e] := range :[x] {\n  :[body]\n}\nREWRITE\n)\"\nCOMBY_RULE=\"$(cat <<\"RULE\"\nwhere match :[x].lsif.hover {\n  | ... map... -> true\n  | ... []... -> true\n  | _ -> false\n}\nRULE\n)\"\ncomby \"$COMBY_MATCH\" \"$COMBY_REWRITE\" -rule \"$COMBY_RULE\" -rg \"-g '*.go'\"\n\n-->"
    },
    {
      "id": "/2022/04/11/comby-decomposer-compiler-fuzzing",
      "metadata": {
        "permalink": "/blog/2022/04/11/comby-decomposer-compiler-fuzzing",
        "source": "@site/blog/2022-04-11-comby-decomposer-compiler-fuzzing.md",
        "title": "Deconstructing programs for compiler fuzzing",
        "description": "table td {",
        "date": "2022-04-11T00:00:00.000Z",
        "formattedDate": "April 11, 2022",
        "tags": [],
        "readingTime": 8.1,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Rijnard",
            "url": "https://twitter.com/rvtond",
            "imageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
          }
        ],
        "frontMatter": {
          "id": "comby-decomposer-compiler-fuzzer",
          "title": "Deconstructing programs for compiler fuzzing",
          "author": "Rijnard",
          "authorURL": "https://twitter.com/rvtond",
          "authorImageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
        },
        "prevItem": {
          "title": "Find and replace with type information",
          "permalink": "/blog/2022/08/31/comby-with-types"
        },
        "nextItem": {
          "title": "Whatever You Want syntax for rewriting code",
          "permalink": "/blog/2021/04/25/whatever-you-want-syntax"
        }
      },
      "content": "<style>\ntable td {\n   padding: 0px;\n   border: none;\n}\ntable tr {\n   padding: 0px;\n   border: none;\n}\nblockquote {\n    text-align: center;\n    background: white;\n    border: 2px solid rgba(1, 1, 1, .1);\n    border-radius: 10px;\n    border-top: 0px;\n    border-bottom: 0px;\n#    border-right: 0px;\n#    border-left: 0px;\n}\n</style>\n\n> I don't want to write a grammar specification for fuzzing compilers. <br><br> I want a shot at crashing the Rust compiler within 24 hours of fuzzing. <br><br> I happen to have test programs for the compiler. Let's just get fuzzing already.\n\n\nFuzzing is the process of generating varied inputs to feed into a program,\nwhere the objective is to discover inputs that crash the program.  These\ncrash-inducing inputs often reveal subtle bugs.  Fuzzing _compilers_ adds an\ninteresting twist because they expect rather structured inputs (like valid Rust\nsource code) that encode a lot of logical complexity for compilers to reason\nabout (think computational constructs like control flow, recursion, and type\nchecking). \n\nThis post is about creatively using source code in compiler tests to exercise\ninteresting compiler behavior quickly (and hopefully crash the compiler sooner\nthan you would otherwise!). The big idea is to\nfirst deconstruct example source programs, then do some criss-cross applesauce\nthat recombines program fragments to generate new inputs. \nIn essence: use\nconcrete programs to create a combinatorial space of potentially valid and\nunique programs that fuzzing can generate and explore over time. \n\n\n![](../../../../img/compiler-decompose-fuzz.svg)\n\n\nThere's a [related paper I co-authored <b>↗</b>](https://agroce.github.io/cc22.pdf) with\ndata that shows that yes, these techniques can likely surface bugs sooner. In\nthis post I focus on the part of that work that I personally found most\ninteresting.  \n\n\nA bit of background on fuzzing compilers. We know compilers expect programs\nthat conform to a language grammar. Exploiting knowledge of a language grammar\nis a well-known way to try and exercise interesting parts of a compiler [[1](https://www.fuzzingbook.org/html/Grammars.html)]. The\nbasic idea there is that you can use a grammar to _generate_ various programs\nthat might end up causing the compiler to run into some corner case and crash\n(yay!). Using a grammar means you're more likely to generate valid programs.\nThis matters because your favorite fuzzer (like\n[AFL++](https://github.com/AFLplusplus/AFLplusplus)) might otherwise end up\nspending a lot of time in shallow, less interesting parts of a compiler (think\nparse errors and error handling for obviously invalid programs) before\ndiscovering paths that lead to deeper compiler logic (say code generation and\noptimization). But it can be a lot of effort to write a grammar specification,\nor turn it into an input generator. Just generally annoying.  Can we sidestep\ngetting into all that?\n\nAnother way to approach this is to say \"Well, I know fuzzing compilers means\ntrying structured inputs that conform to the underlying grammar. I happen to\nhave programs from the compiler's test suite. Let's get fuzzing already.\" And\nyes, that's a grand way to start off: grab the already-valid programs,\noptionally have the fuzzer trim the corpus based on some feedback from\ninstrumentation, and off you go. And now we get to the part where I\ntell you \"Hey hang on, before you run off, we can get a bit more creative with\nthose tests. It's cheap and pretty easy to get started, and you might just find bugs that much quicker.\nHave you heard of [comby-decomposer](https://github.com/comby-tools/comby-decomposer)?\"\n\n## Deconstructing programs with [comby-decomposer](https://github.com/comby-tools/comby-decomposer)\n\nExisting programs in a compiler's test suite typically hand-crafted by expert\ncompiler writers to test phases like parsing, type checking, optimization, and\ncode generation. These tests are extremely valuable for exercising broad\nfunctionality of a compiler, and it only makes sense to include them in the\nfuzzing corpus if we're going to hunt for corner cases. Tuning the initial\ncorpus can reasonably stop here, and it's fairly \"safe\" to just rely on\nfeedback-driven fuzzers to synthesize valid, interesting, and \n[structured input over time. <b>↗</b>](https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html)\nBut we have an opportunity to be a bit smarter when it comes to compiler\nfuzzing.  \n\nLet's not _only_ start off with just the initial programs, but also use\nthose initial programs to create new, unique combinations of likely-valid and\nnever-before-seen programs. This is what I created\n[comby-decomposer](https://github.com/comby-tools/comby-decomposer) for,\na tool that chops up program source code in basically any way you'd like.\nLet's look at an example using this test program inspired by the [Solidity contract language](https://sourcegraph.com/github.com/ethereum/solidity/-/blob/test/libsolidity/syntaxTests/nameAndTypeResolution/002_undeclared_name.sol).\n\n\n```\nfunction f(uint256 arg) public {\n  g(notfound);\n}\n```\n\nOne interesting way to chop this up is to recognize that valid and varied expressions\nexist between balanced delimiters like `(...)` or blocks delineated by\n`{...}`. We don't need to know all the details of the Solidity grammar. Just by\neyeballing the concrete test program, we can intuit that there are interesting\nterms or expressions inside general syntax like parentheses and\nbraces.\n\n`comby-decomposer` takes a [comby pattern](https://comby.dev/docs/syntax-reference) like `(:[1])`\nand will then split up the input program into two sets with respect to this pattern. First a\nset of templates, which is just the original program templatized with respect\nto the holes input pattern (you can think of this as _un_-substituting matches).\nSecond, the set of fragments matching holes in the input pattern. We can use\nany `comby` pattern. In this example, let's use the\ninput patterns `(:[1])` and `{:[1]}`. Here's the diagram of terms matched\nbetween the delimiters, and the two output sets generated (templates left,\nfragments right).\n\n![](../../../../img/program-deconstruct.svg)\n\nThis output gives a lot of freedom for building new programs: any of these\nfragments may be substituted into any of the templates (and there's a server\nincluded in\n[comby-decomposer](https://github.com/comby-tools/comby-decomposer#on-demand-input-generation)\nto generate these inputs randomly and on-demand).  The combinations for this\nsimple program aren't very interesting or necessarily valid.  This simple\nexample also shows just one hole created in templates, but `comby-decomposer` will\ncreate templates with multiple holes too, or holes for nested terms.  The point\nis to apply this idea to an entire test suite, yielding a combinatorial space\nof potentially unique and valid programs to explore over time. \n\n## Fuzz results: what difference does [comby-decomposer](https://github.com/comby-tools/comby-decomposer) make?\n\n\n\n`comby-decomposer` supplements the \nhybrid fuzzing approach explained in [the paper I mentioned before](https://agroce.github.io/cc22.pdf) to generate more varied inputs earlier during fuzzing.\nThe main takeaway for\n`comby-decomposer` is that using the tool with hybrid strategies\ngenerally found more bugs within a 24-hour window than approaches without it\n(we ran 210 days worth of fuzzing to create a controlled experiment and we say\n\"more bugs\" by counting unique bugs according to ground truth developer fixes,\nnot fuzzer bucketing which is inaccurate). In the extreme, \nusing `comby-decomposer` found on average 7 bugs in the Zig compiler whereas all\nother approaches found less than 3 on average. Many of the unique findings are interesting, in the\nsense that they trigger [crashes in code analysis and generation <b>↗</b>](https://docs.google.com/spreadsheets/d/1k79eqGpYgXAcwtDbHoIhUjezmlviZrV9M9ueL_JJJ5A/edit#gid=0). \nSome crashing programs found exclusively by `comby-decomposer` are quite large, even after running [comby-reducer](../../../../blog/2021/03/26/comby-reducer). These likely trigger\nmore complex reasoning in the compiler:\n\n```zig\nvar frame: ?anyframe = null;\n        export fn a() void {\n            _ = async rangeSum(10);\n        }\n        fn rangeSum(x: i32) i32 {\n            suspend {\nwhile(1==1)\n                frame = @frame();\n            }\n            if (x == 0) return 0;\n            var child = rangeSumIndirect;\n            return child + 1;\n        }\n        fn rangeSumIndirect(x: i32) i32 {\n            if (x == 0) return 0;\n            var child = rangeSum;\n            return child + 1;\n        }\n```\n\n### Let's crash the Rust compiler?\n\nAnecdotally, I took `comby-decomposer` for a spin on the latest Rust compiler\nwhile writing this post.  It found one crashing input in just 20 hours, here's\nthe reduced version:\n\n\n```rust\nextern \"\" {\nasync fn partial_init() -> u32 {\nasync fn hello_world() {}\n}\n}\n```\n\nUnfortunately (for me) this bug was already found and [reported](https://github.com/rust-lang/rust/issues/95829) by\n[fuzz-rustc](https://github.com/dwrensha/fuzz-rustc) just a couple of days\nprior.  But I take solace knowing that there's a sporting chance to find\ncrashing inputs for the Rust compiler in less than 24 hours. For this fuzzing\ncampaign I ran on just a single core and decomposed only more recent regression\ntests (around 200 odd tests).\nThis because recent regressions are more juicy for testing, in case a\nfix may be incomplete. The 200 tests yielded around 1,600 templates and 1,300\nfragments. \n\n### Running it yourself\n\n👉To do program decomposition, check out the main\n[comby-decomposer](https://github.com/comby-tools/comby-decomposer) project.\n\n👉For fuzzing, check out this modified [AFL fuzzer for\ncompilers](https://github.com/agroce/afl-compiler-fuzzer#01-usage) that\nworks with the `comby-decomposer` server to request new inputs on-demand. \n\n👉Have other grand ideas to fuzz compilers and wondering if this could be useful? Post in the [issue tracker](https://github.com/comby-tools/comby-decomposer/issues/new) or [DM @rvtond](https://twitter.com/rvtond).\n\n## When to choose [comby-decomposer](https://github.com/comby-tools/comby-decomposer)\n\nThere are two fundamentally practical ideas that make `comby-decomposer` one of the best tools for breaking up programs today:\n\n- <b>You can generate well-formed templates and fragments for practically [any language](../docs/overview#does-it-work-on-my-language)</b> because it builds on `comby` to parse the program. It even decomposes nested syntax (a practically impossible task for regex-based engines). Want templates and fragments for Kotlin? Just find some Kotlin programs and tell `comby-decomposer` they're Kotlin files.\n\n- <b>You can decompose programs with respect to _any_ pattern that `comby` recognizes.</b> You don't have to decompose with respect to a pattern like `(:[1])` in the example. Maybe you're fuzzing a domain where you only want to decompose with respect to numbers. So, you could just specify a regular expression pattern like `[0-9]`. Since `comby` supports regular expression matching too, you'd just specify this in `comby` with  `[~[0-9]+]` [see the docs for more <b>↗</b>](https://github.com/comby-tools/comby-decomposer#customizing-decomposition).\n\n[comby-decomposer](https://github.com/comby-tools/comby-decomposer) was developed in part to make it extremely easy to generate\ninputs and fuzz compilers for domain-specific applications\n([Solidity](https://docs.soliditylang.org/en/v0.8.13/) and\n[Move](https://move-book.com/) for smart contracts) and up-and-coming languages\nlike [Zig](https://ziglang.org/).  Other tools exist to generate programs for\ntesting and fuzzing ([CSmith](https://github.com/csmith-project/csmith)\nanyone?) and maybe they're more suitable or mature for your language. But none\nare as dead simple and broadly language general to the degree that `comby`\nmakes possible. So that's why `comby-decomposer` exists now."
    },
    {
      "id": "/2021/04/25/whatever-you-want-syntax",
      "metadata": {
        "permalink": "/blog/2021/04/25/whatever-you-want-syntax",
        "source": "@site/blog/2021-04-25-whatever-you-want-syntax.md",
        "title": "Whatever You Want syntax for rewriting code",
        "description": "table td {",
        "date": "2021-04-25T00:00:00.000Z",
        "formattedDate": "April 25, 2021",
        "tags": [],
        "readingTime": 11.46,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Rijnard",
            "url": "https://twitter.com/rvtond",
            "imageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
          }
        ],
        "frontMatter": {
          "id": "whatever-you-want-syntax",
          "title": "Whatever You Want syntax for rewriting code",
          "author": "Rijnard",
          "authorURL": "https://twitter.com/rvtond",
          "authorImageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
        },
        "prevItem": {
          "title": "Deconstructing programs for compiler fuzzing",
          "permalink": "/blog/2022/04/11/comby-decomposer-compiler-fuzzing"
        },
        "nextItem": {
          "title": "A simple program reducer for any language",
          "permalink": "/blog/2021/03/26/comby-reducer"
        }
      },
      "content": "<style>\ntable td {\n   padding: 0px;\n   border: none;\n}\ntable tr {\n   padding: 0px;\n   border: none;\n}\nblockquote {\n    text-align: center;\n    background: white;\n    border: 2px solid rgba(1, 1, 1, .1);\n    border-radius: 10px;\n    border-top: 0px;\n    border-bottom: 0px;\n#    border-right: 0px;\n#    border-left: 0px;\n}\n</style>\n\n> We have color themes for our IDEs. We should have syntax themes for our tools.\n\nSearch and Replace commands could look like this.\n\n`swap($1, $2)` → `swap($2, $1)`\n\n`swap(α, β)` → `swap(β, α)`\n\n`swap(🐵, 🍌)` → `swap(🍌, 🐵)`\n\nWith Whatever You Want (WYW) syntax, it's really up to you.\n\n---\n\nLike many pattern-matching languages,\n[`comby`](https://github.com/comby-tools/comby) recognizes some reserved syntax\nthat has special meaning for matching input. Think of a `grep` pattern like\n`.*`. Here the reserved syntax `.` means mean \"match any character\" and `*`\nmeans \"repeat matching the previous expression zero or more times\". In the rest\nof this post I'll just call this reserved syntax a metasyntax. `comby`\npredominantly uses a metasyntax that looks like this:\n\n`:[`_`var`_`]`\n\nwhich roughly means \"match anything within well-balanced syntax for some\nlanguage _L_ and bind those contents to variable _var_\". There are some\nvariations of this syntax for other matching behaviors (you can [find the\nreference here](../../../../docs/syntax-reference)) but that's not\nimportant for this post.\n\nIn some sense, syntax variety is the spice of programming languages. If you're\ndesigning a new language you have to pick _something_, and you're probably going\nto balance picking some familiar syntax (a la \"parentheses seem reasonable for\narithmetic expressions, we're not barbarians\") but then also sprinkle in some\nunique things so that your grammar isn't accidentally isomorphic to Java. Your\ndecisions may retain the loyalty of early adopters (`make` famously stuck with\ntabs instead of spaces [to not disrupt the early dozen or so\nusers](https://beebo.org/haycorn/2015-04-20_tabs-and-makefiles.html)). Or you\nmight [dismay academics on twitter](https://twitter.com/ShriramKMurthi/status/1359543291587551239).\nWhatever you decide, it's really your privilege.\n\nI didn't really like settling on a metasyntax for `comby`. It's difficult to\nanticipate what the consequences of settling on a syntax are. Maybe I'm\ndesigning myself into a corner and it'll make future syntax extensions\nimpossible. Maybe the syntax will cause an Angular programmer to break out in\nhives. I just wanted it to be minimal, and I wanted it to be easy to assign\nmatched contents to variables. Not something like `(?P<name>pattern)` syntax of\nnamed groups in some regular expression dialects.\n\nSince then, I've wanted to experiment with other syntax. For example, I noticed\nthat the [`gofmt` tool shows an example using Greek unicode letters as variables](https://golang.org/cmd/gofmt/#hdr-Examples).\n\n```bash\ngofmt -r 'α[β:len(α)] -> α[β:]'\n```\n\nAnd so I latched onto this idea of being less fastidious about syntax design.\n\nYes, allowing different language syntax can lead to fragmented and inconsistent\ntooling. But who am I to deprive you from shooting yourself in the foot, O\nmighty developer? Besides, if the tooling is malleable, maybe we can shape it to\nbe in line and consistent with pervading opinions.\n\nI factored out the metasyntax definition in `comby` to support Whatever You\nWant syntax. With WYW syntax it's possible to attach the native matching\nbehavior (semantics) implemented in `comby` to basically arbitrary syntax.\nSyntax definitions are defined in JSON. The rest of this post showcases some WYW\ndefinitions: the reasonable, the laughable, and the deplorable.\n\n## Default syntax definition\n\nTo ground things, the examples below run a transformation on the input `swap(x,\ny)` and rewrites it to `swap(y, x)`. Here's an invocation of a swap transformation in the\ndefault metasyntax.\n\n```bash\necho 'swap(x, y)' | \\\ncomby -stdin \\\n'swap(:[1], :[2])' 'swap(:[2], :[1])'\n```\n\nproduces\n\n```diff\n@|-1,1 +1,1 ============================================================\n-|swap(x, y)\n+|swap(y, x)\n```\n\nBelow is the JSON definition for this metasyntax. Entries correspond to the\nmatching behavior described in the\n[reference](../../../../docs/syntax-reference). No need to dwell on this\nformat--this blog post is really just about enjoying the show. Have a look at\nthe detailed page for [defining your own metasyntax](../../../../docs/advanced-usage#custom-comby-metasyntax) if you want particulars\nafter reading.\n\n<details>\n  <summary><strong>Expand for JSON definition</strong></summary>\n\n```json\n{\n  \"syntax\": [\n    [ \"Hole\", [ \"Everything\" ], [ \"Delimited\", \":[\", \"]\" ] ],\n    [ \"Hole\", [ \"Expression\" ], [ \"Delimited\", \":[\", \":e]\" ] ],\n    [ \"Hole\", [ \"Alphanum\" ],   [ \"Delimited\", \":[[\", \"]]\" ] ],\n    [ \"Hole\", [ \"Non_space\" ],  [ \"Delimited\", \":[\", \".]\" ] ],\n    [ \"Hole\", [ \"Line\" ],       [ \"Delimited\", \":[\", \"\\\\n]\" ] ],\n    [ \"Hole\", [ \"Blank\" ],      [ \"Delimited\", \":[ \", \"]\" ] ],\n    [ \"Regex\", \":[\", \"~\", \"]\" ]\n  ],\n  \"identifier\":\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"\n}\n```\n\n</details>\n\n## Dolla dolla bills\n\nDolla syntax is an entirely reasonable alternative syntax where `$` prefixes\nvariables alphanumeric variables.\n\n\n```bash\necho 'swap(x, y)' | \\\ncomby -stdin -custom-metasyntax dolla.json \\\n'swap($1, $2)' 'swap($2, $1)'\n```\n\nThis is a common and familiar syntax in Bash, Perl, PHP, and similar languages.\nIt is also a bit more terse than the default `comby` syntax. You might be\nwondering You might ask \"What if I want to match a the literal syntax `$var`,\nwon't that conflict with this metasyntax?\". See the [section on escaping](#on-escaping) later\nin this post if you're interested in this corner case.\n\n<details>\n  <summary><strong>JSON definition of Dolla metasyntax</strong></summary>\n\n```json\n\n{\n  \"syntax\": [\n    [ \"Hole\", [ \"Everything\" ], [ \"Delimited\", \"$*\", null ] ],\n    [ \"Hole\", [ \"Expression\" ], [ \"Delimited\", \"$\", null ] ],\n    [ \"Hole\", [ \"Alphanum\" ],   [ \"Delimited\", \"$$\", null ] ],\n    [ \"Regex\", \"$\", \"~\", \".\" ]\n  ],\n  \"identifier\":\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"\n}\n\n```\n\n</details>\n\n\n## Lambda syntax\n\nTo use similar Greek letters like the `α[β:]` syntax show before, I made it\npossible to associate any unicode string with the matching behaviors that\n`comby` supports. This is legitimately useful for avoiding syntax conflicts, and\nalso very terse.\n\n\n```bash\necho 'swap(x, y)' | \\\ncomby -stdin -custom-metasyntax lambda.json \\\n'swap(α, β)' 'swap(β, α)'\n```\n\nAnd if we wanted to match any kind of function name like `swap`, we could use a\nvariable λ if desired.\n\n```bash\necho 'swap(x, y)' | \\\ncomby -stdin -custom-metasyntax lambda.json \\\n'λ(α, β)' 'λ(β, α)'\n```\n\nI like this. The only challenge is that I can't easily find these symbols on my\nkeyboard.\n\n<details>\n  <summary><strong>JSON definition of Lambda metasyntax</strong></summary>\n\n```json\n{\n  \"syntax\": [\n    [ \"Hole\", [ \"Everything\" ], [ \"Delimited\", \"place-holder\", null ] ],\n    [ \"Hole\", [ \"Everything\" ],\n        [ \"Reserved_identifiers\",\n            [ \"Γ\", \"Δ\", \"Θ\", \"Λ\", \"Ξ\", \"Π\", \"Σ\", \"Φ\", \"Ψ\", \"Ω\" ]\n        ]\n    ],\n    [ \"Hole\", [ \"Expression\" ],\n        [ \"Reserved_identifiers\",\n            [\n                \"α\", \"β\", \"γ\", \"δ\", \"ε\", \"ζ\", \"η\", \"θ\", \"ι\", \"κ\", \"λ\",\n                \"μ\", \"ξ\", \"π\", \"ρ\", \"ς\", \"σ\", \"τ\", \"υ\", \"φ\", \"χ\", \"ψ\",\n                \"ω\"\n            ]\n        ]\n    ],\n  ],\n  \"identifier\":\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"\n}\n```\n\n</details>\n\n\n## Emoji Movie\n\nI did say any unicode string, so emojis count.\n\n```bash\necho 'swap(x, y)' | \\\ncomby -stdin -custom-metasyntax emoji.json \\\n'swap(🐵, 🍌)' 'swap(🍌, 🐵)'\n```\n\nWhen variables are used multiple times in a pattern, it implies that they should\nbe textually equal. For example, if we wanted to check that two arguments of an\n`add` function are equal, we could write a transformation like this:\n\n```bash\necho 'add(x, x)' | \\\ncomby -stdin \\\n'add(:[v], :[v])' 'multiply(2, :[v])'\n```\n\n```diff\n@|-1,1 +1,1 ============================================================\n-|add(x, x)\n+|multiply(2, x)\n```\n\nThis equals relation is still valid when the syntax is redefined. So we can\ninstead equivalently write this in preferred emoji syntax.\n\n```bash\necho 'add(x, x)' | \\\ncomby -stdin -custom-metasyntax emoji.json \\\n'add(😂, 😂)' 'multiply(2, 😂)'\n```\n\n```diff\n@|-1,1 +1,1 ============================================================\n-|add(x, x)\n+|multiply(2, x)\n```\n\n<details>\n  <summary><strong>JSON definition of Emoji metasyntax</strong></summary>\n\n```json\n{\n  \"syntax\": [\n    [ \"Hole\", [ \"Everything\" ], [ \"Delimited\", \"place-holder\", null ] ],\n    [ \"Hole\", [ \"Everything\" ],\n        [ \"Reserved_identifiers\",\n            [ \"❤️\", \"💙\", \"💚\", \"💜\", \"💛\", \"🧡\" ]\n        ]\n    ],\n    [ \"Hole\", [ \"Expression\" ],\n        [ \"Reserved_identifiers\",\n            [ \"😂\", \"🚡\", \"😃\", \"😬\", \"😈\", \"🐵\", \"✋\", \"😻\", \"🍌\" ]\n        ]\n    ]\n  ],\n  \"identifier\":\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"\n}\n```\n\n</details>\n\n\n## Wutspace\n\nAny unicode string. So of course whitespace is allowed. If whitespace conflicts\nwith the some other part of the pattern, you'll have to find an escape mechanism\nto match whitespace literally. This is WYW syntax: your syntax, your problems\n🙂. If we use whitespace as identifiers, we'll need unique ones when we don't\nwant matches to be equal. So we'll choose `<space>` and `<space><space>` to demo\nthe `swap` example. We're also going remove spaces in our input, because that\nintroduces ambiguity. But anyway, you end up in a world where this can make some\nkind of sense.\n\n```bash\necho 'swap(x,y)' | \\\ncomby -stdin -custom-metasyntax wutspace.json \\\n'swap( ,  )' 'swap(  , )'\n```\n\n<details>\n  <summary><strong>JSON definition of Wutspace metasyntax</strong></summary>\n\n```json\n{\n  \"syntax\": [\n    // Currently a placeholder is needed if we only care about Reserved_idenitifersl to avoid trickery.\n    // Order is significant.\n    [ \"Hole\", [ \"Everything\" ], [ \"Delimited\", \"place-holder\", null ] ],\n    [ \"Hole\", [ \"Everything\" ],\n        [ \"Reserved_identifiers\",\n            [ \"  \", \" \" ]\n        ]\n    ]\n  ],\n  \"identifier\":\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"\n}\n```\n\n</details>\n\n## suǝɹɐd\n\nThat's parens upside down. Because it's (un)naturally possible to define\ninverted parentheses as variable delimiters.\n\n```bash\necho 'swap(x, y)' | \\\ncomby -stdin -custom-metasyntax inverted-parens.json \\\n'swap()1(, )2()' 'swap()2(, )1()'\n```\n\n\n<details>\n  <summary><strong>JSON definition of inverted parens metasyntax</strong></summary>\n\n```json\n{\n  \"syntax\": [\n   [ \"Hole\", [ \"Everything\" ], [ \"Delimited\", \")\", \"(\" ] ],\n   [ \"Hole\", [ \"Expression\" ], [ \"Delimited\", \"))\", \"((\" ] ]\n  ],\n  \"identifier\":\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"\n}\n```\n\n</details>\n\n## Dangling\n\nFor maximum confusion, just define a prefix `)` for variables. Comby won't\nconfuse that metasyntax with well-balanced parentheses because metasyntax takes\npriority during parsing.\n\n\n```bash\necho 'swap(x, y)' | \\\ncomby -stdin -custom-metasyntax dangling.json \\\n'swap()1, )2)' 'swap()2, )1)'\n```\n\n<details>\n  <summary><strong>JSON definition of Dangling metasyntax</strong></summary>\n\n```json\n{\n  \"syntax\": [\n   [ \"Hole\", [ \"Everything\" ], [ \"Delimited\", \")\", null ] ],\n   [ \"Hole\", [ \"Expression\" ], [ \"Delimited\", \"))\", null ] ]\n  ],\n  \"identifier\":\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"\n}\n```\n\n</details>\n\n## Summary\n\nThere you have it. Maybe you'd like to define a templating language with\n`{{var}}` or something else, it's Whatever You Want. For the curious reader, and\nto characertize some of the technical details more concretely, I cover some more\nthoughts on related tools and techniques below.\n\n### On syntax definitions\n\n**Language workbenches** define programming languages to the nth degree--not\nonly the syntax, but also static and dynamic semantics, and more. A prime\nexample is [Spoofax](http://www.metaborg.org/en/latest/index.html).\n[SDF3](http://www.metaborg.org/en/latest/source/langdev/meta/lang/sdf3/introduction.html)\nis Spoofax's interface for defining language syntax. Generally, syntax\ndefinition here defines a grammar of input syntax to recognize, and parsing the\ninput yields a concrete syntax tree or abstract syntax tree representation. This\ntree is later interpreted or evaluated by another program to perform some\ncomputation.\n\nThe WYW metasyntax definition in `comby` operates rather differently. It only\nlets you define a comparatively simple syntax for some fields in a JSON format\n(you're not defining a grammar here, just some parts of it). And then, those\ndefinitions are only associated with preexisting computations that `comby`\nimplements (roughly, language-aware context-free matching). Indeed,\n`comby` is built on the premise that no explicit parse tree or abstract syntax\ntree is needed at all to perform its syntax-tree rewriting. The `comby`\nmetasyntax definitions directly parameterize matching behavior and there is no\nin-between tree representation. Because there is no in-between tree\nrepresentation, the use cases and goals of `comby` metasyntax definitions are\nsimpler and rather less powerful than syntax definition frameworks found in\nlanguage workbenches.\n\n**Macros** are a well-known abstraction in languages that can (re)define syntax.\n[Racket `define-syntax`](https://docs.racket-lang.org/reference/define.html) and\n[Rust macros](https://doc.rust-lang.org/rust-by-example/macros.html) are\nnotable. Macro definitions are different compared to `comby` metasyntax\ndefinitions in this post in the sense that macro systems can generally\nintroduce arbitrary computation. With `comby`, the metasyntax definitions only\nparameterize existing match behaviors.\n\n### On escaping\n\nWhat happens if you define a metasyntax where `$x` is a variable but you want to\nmatch the literal string `$x`? One way to avoid this is to change the\nmetasyntax, but that can be inconvenient. Comby deals with syntax conflicts in a\ngeneric way by allowing an escape hatch via regular expression matching. Because\nregular expression syntax recognizes escape sequences (e.g., `\\.` to match `.`\nliterally) we can just match conflicting syntax literally via regular expression\nescaping. This way, you get embedded regular expression matching (should you\nchoose to make use of it) and a built-in escape hatch for those rare cases of\nconflicting syntax. As far as corner cases for quoting and escape hatches go, I\nfind it's simpler to just piggyback on an established regular expression\nlanguage that uses `\\`-escaping rather than expose an entirely new interface\nthat requires you to invent a custom escape syntax.\n\nTo make this work, `comby` just needs a metasyntax definition for embedding\nregular expressions. By default, `comby` uses `:[<variable>~<regex>]` for\nembedding regular expressions. We could define an alternative metasyntax like\n`$<variable>~<regex>.` Here the syntax definition allows you to customize the\nprefix and suffix syntax `$` and `~` parts. The suffix, in this case `.`, is\nimportant so that we can recognize when to stop scanning this metasyntax, since\nthe expression `<regex>` may be any character allowed by the regular expression\nlanguage. Once this part is defined, you can match `$var` literally with a\npattern like `$1~$var.`.\n\n```bash\necho 'swap($x, $y)' | \\\ncomby -stdin -custom-metasyntax dolla.json \\\n'swap($1~$x., $2)' 'swap($2, $1)' # matches the first $x literally\n```\n\n```diff\n@|-1,1 +1,1 ============================================================\n-|swap($x, $y)\n+|swap($y, $x)\n```\n\nAs far as search-replace tools, it's worth mentioning a related idea here in\n`sed`. It's a lesser known fact that `sed` actually accepts arbitrary characters\nto delimit search and replace patterns. Most online examples use `/`:\n\n```\n$ echo 'http' | sed 's/http/https/'\n> https\n```\n\nBut you can really choose any character. This is especially useful when the\ninput contains `/`, which you'd need to escape otherwise. Instead of\n\n```\n$ echo 'http://' | sed 's/http:\\/\\//https:\\/\\//'\n> https://\n```\n\nYou could use a `~`:\n\n```\n$ echo 'http://' | sed 's~http://~https://~'\n> https://\n```"
    },
    {
      "id": "/2021/03/26/comby-reducer",
      "metadata": {
        "permalink": "/blog/2021/03/26/comby-reducer",
        "source": "@site/blog/2021-03-26-comby-reducer.md",
        "title": "A simple program reducer for any language",
        "description": "table td {",
        "date": "2021-03-26T00:00:00.000Z",
        "formattedDate": "March 26, 2021",
        "tags": [],
        "readingTime": 12.965,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Rijnard",
            "url": "https://twitter.com/rvtond",
            "imageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
          }
        ],
        "frontMatter": {
          "id": "comby-reducer",
          "title": "A simple program reducer for any language",
          "author": "Rijnard",
          "authorURL": "https://twitter.com/rvtond",
          "authorImageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
        },
        "prevItem": {
          "title": "Whatever You Want syntax for rewriting code",
          "permalink": "/blog/2021/04/25/whatever-you-want-syntax"
        },
        "nextItem": {
          "title": "Comby website gets a refresh",
          "permalink": "/blog/2020/06/10/new-blog-site"
        }
      },
      "content": "<style>\ntable td {\n   padding: 0px;\n   border: none;\n}\ntable tr {\n   padding: 0px;\n   border: none;\n}\n</style>\n\nI've been fuzzing compilers for less familiar languages like [Solidity](https://github.com/ethereum/solidity) and [Diem](https://github.com/diem/diem) (for smart contracts), and up-and-coming languages like [Zig](https://ziglang.org/). [More on that fuzzing effort here](https://blog.trailofbits.com/2021/03/23/a-year-in-the-life-of-a-compiler-fuzzing-campaign/).\nA fun part of that is looking at programs that crash the compilers. Reducing\nthose programs to submit in bug reports... less so. Thing is, I want to submit programs that are small and comprehensible for maintainers, and doing things by hand got tedious after about 5 reports. There _are_ tools for reducing programs out there, but none really checked the boxes I wanted. So I wrote [`comby-reducer`](https://github.com/comby-tools/comby-reducer#readme) to check those boxes, and things became a lot more fun:\n\n<input type=\"checkbox\" checked> Works on basically any language syntax or structured format (including e.g., DSLs)\n<br>\n<input type=\"checkbox\" checked> Syntax-aware (not just regex), but without strictly requiring grammar definitions\n<br>\n<input type=\"checkbox\" checked> Easy to define and include/exclude transformations (declarative, no scripting)\n<br>\n<input type=\"checkbox\" checked> Easy to see what it did (so I can tweak transformations)\n<br>\n<input type=\"checkbox\" checked> Easy to install and invoke\n<br>\n<input type=\"checkbox\"> Fast on large inputs? Most of the crashing inputs are small, this not as important\n\nBasically, something dead simple that allows easy tweaking for transforming\nsyntax.\n\n## How it works\n\n`comby-reducer` is built using [`comby`](https://github.com/comby-tools/comby),\nwhich supports a lightweight way of rewriting syntactic structures of a\nprogram's parse tree, like expressions and function blocks. Comby is\nlanguage-aware and understands basic syntax of code, strings, and comment syntax\nfor many languages. Absent language-specific parsers, `comby` uses a generic\nparser that works well for syntactic constructs in DSLs and less mainstream\nlanguages. You can [learn more about comby here](https://comby.dev/docs/overview).\n\n`comby-reducer` uses a JavaScript library transpiled from `comby`'s core parser\nengine, and a couple of functions for transforming a program to a fixed point.\n\nLet's move on to examples. If you want, you can learn more about how program\nreducers work by checking out the [resources at the end of this post](#learn-more).\n\n## A program reduction tour\n\nSome fuzzing found this program crashed the [`Move` compiler](https://github.com/diem/diem/tree/main/language/move-lang).\n\n```rust\nmodule M {\n    resource struct R {}\n    struct Cup<T> {}\n\n    fun t0(x8: u8, x64: u64, x128: u128) {\ncontinue;\n        (false as u8);\n        (true as u128);\n\n        (() as u64);\n        (1,1\n);\n\n        (0 as bool);\n        (0 as address);\n        R = (0 as R);\n        (0 as Cup<u8>);\n        (0 as ());\n        (0 as (u64, u8));\n\n        (x\"1234\" as u64);\n    }\n}\n```\n\n`comby-reducer` reduces the program to something I'd be happy to submit in a bug report:\n\n```rust\nmodule M {\n    resource struct R {}\n    fun t0() {\n        R = ();\n    }\n}\n```\n\n`Move` syntax is a similar `Rust` syntax, and like many languages, uses parentheses `()`\nand braces `{}` to delineate and nest expressions that correspond to an\nunderlying parse tree. `comby-reducer` understands these syntactic constructs\nwell, and can transform content inside balanced parentheses and braces (but won't\nget confused if special characters like `(` happen inside strings or comments).\n\nThis program crashes the [Zig](https://ziglang.org/) compiler:\n\n```zig\nconst BitField = packed struct {\n            a: u3,\n            b: u3,\n            c: u2,\n        };\n\n        fn foo(error.Hi\n) u3 {\n            return bar(&bit_field.b);\n        }\n\n        fn bar(x: *const u3) u3 {\n            return x.*;\n        }\n\n        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n```\n\nand reduces to another happy candidate for a bug report:\n\n```zig\n        fn foo(error.Hi) u3 {}\n        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n```\n\nAnd here's a reduced [Solidity](https://github.com/ethereum/solidity) smart contract:\n\n```solidity\ncontract C {\n    function f(uint256[] calldata x, uint256 s, uint256 e) external returns (uint256) {\n        (x[s:e]).length;\n    }\n}\n```\n\n<details>\n  <summary><strong>Expand to see original Solidity program</strong></summary>\n\n\n```solidity\npragma experimental ABIEncoderV2;\ncontract C {\n    function f(uint256[] calldata x, uint256 s, uint256 e) external returns (uint256) {\n        (x[s:e]).length;\n    }\n    function f(uint256[] calldata x, uint256 s, uint256 e, uint256 ss, uint256 ee) external returns (uint256) {\n        return uint256[](x[s:e][ss:ee]).length;\n    }\n    function f_s_only(uint256[] calldata x, uint256 s) external returns (uint256) {\n        return uint256[](x[s:]).length;\n    }\n    function f_e_only(uint256[] calldata x, uint256 e) external returns (uint256) {\n        return uint256[](x[:e]).length;\n    }\n    function g(uint256[] calldata x, uint256 s, uint256 e, uint256 idx) external returns (uint256) {\n 111111111111111111256[](x[s:e])[idx];\n    }\n    function gg(uint256[] calldata x, uint256 s, uint256 e, uint256 idx) external returns (uint256) {\n        return x[s:e][idx];\n    }\n    function gg_s_only(uint256[] calldata x, uint256 s, uint256 idx) external returns (uint256) {\n        return x[s:][idx];\n    }\n    function gg_e_only(uint256[] calldata x, uint256 e, uint256 idx) external returns (uint256) {\n        return x[:e][idx];\n    }\n}\n```\n\n</details>\n\n\n## Declaring transformations\n\n`comby-reducer` uses around 20 transformations to produce the above.\nThese are [in the repo](https://github.com/comby-tools/comby-reducer/blob/master/transforms/config.toml),\nbut you can also see a sample of them by expanding the below tab to get a sense of things. Transformations are\ndefined using [comby syntax](https://comby.dev/docs/syntax-reference), and we'll walk through some of them.\n\n<details>\n  <summary><strong>Some simple reduction transformations</strong></summary>\n\n```toml\n[delete_paren_content]\nmatch='(:[1])'\nrewrite='()'\nrule='where nested'\n\n[delete_brace_content]\nmatch='{:[1]}'\nrewrite='{}'\nrule='where nested'\n\n# Helps put blank bodies across newlines on the same line for line deletion.\n[blank_brace]\nmatch='{ }'\nrewrite='{}'\n\n[delete_line]\nmatch=':[x\\n]'\nrewrite=''\n\n[delete_string_content]\nmatch='\":[x]\"'\nrewrite='\"\"'\n\n[remove_first_paren_element]\nmatch='(:[1],:[2])'\nrewrite='(:[2])'\n```\n\n</details>\n\n```toml\n[delete_paren_contents]\nmatch='(:[1])'\nrewrite='()'\nrule='where nested'\n```\n\nThis transformation matches any content between balanced parentheses (including\nnewlines) and deletes the content. The `:[1]` is a variable that binds to\nmatched content. By default, `comby-reducer` will try to apply this\ntransformation at the top-level of a file, wherever it sees `(...)`. The\n`rule='where nested'` tells comby-reducer that it should also attempt to reduce\nnested matches of `(...)` inside other matched `(...)`. In general, parentheses\nare a common syntax to nest expressions in programs, so it makes sense to add\n`rule='where nested'`.\n\n\nAnother transformation preserves the first comma-separated element inside parentheses:\n\n```\n[remove_first_paren_element]\nmatch='(:[1],:[2])'\nrewrite='(:[2])'\n```\n\nProgram syntax often use call or function-like syntax that comma-separate\nparameters or arguments inside parentheses. This transformation attempts to remove\nelements in such syntax. This transform doesn't have a rule part, since it might\nnot be as fruitful to attempt nested reductions inside of `:[1]` or `:[2]`. But,\nwe could easily add it.\n\nThe default transformations aren't very language-specific and worked well to\nreduce the languages I dealt with (Solidity, Move, Zig) to small\nhuman-comprehensible programs. Of course, you can define your own\ntransformations with the desired level of syntactic specificity. E.g., we might\nremove `for` loops in JavaScript with:\n\n```\n[remove_js_style_for_loop]\nmatch='''\nfor (:[1]) {\n  :[2]\n}\n'''\nrewrite=''\n```\n\n\n## Observing and replaying reduction\n\nWhile running `comby-reducer`, I noticed that programs would often reduce to structures like:\n\n```solidity\nfunction foo() {\n}\n```\n\nAfter some sequence of transformations, a block might end up empty, but contain whitespace. To crunch these, I added the transformation\n\n```toml\n[blank_brace]\nmatch='{ }'\nrewrite='{}'\n```\n\nThis transformation simply deletes contiguous whitespace (including newlines).\nIn turn, this often lead to a reduction to something like `func () {}` which\nthen ends up being removed by a transformation that deletes lines. Nice!\n\nBecause I had an easy way to introduce new transformations, I wanted more\ninsight into how transformations behaved. This helped me understand what I\ncould add to help reduction along, or even just discover transformations that\nwould improve formatting.\n\nFor example, I noticed one Zig program reduced to:\n\n```zig\n        fn foo(error.Hi\n) u3 {}\n        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n```\n\nHere I just wanted to group the first pair of parentheses pair on one line like\n`fn foo(error.Hi) u3 {}`. So I added something that would match all content up\nto trailing whitespace within balanced parentheses:\n\n```toml\n[delete_trailing_paren_whitespace]\nmatch='(:[1] )'\nrewrite='(:[1])'\n```\n\nTo make this process a bit more snazzy, I added a way to replay transformations.\n`comby-reducer` takes a `--record` argument, and the output can be replayed with\n`comby-reduce-replay`. This makes it possible to step through the process.\nHere's an example where I manually step through the Zig reduction.\n\n<video style=\"width:100%;margin-top:0.5em;border-radius:5px\" autoPlay controls>\n  <source src=\"/img/zig-reduce-simple.mp4\" type=\"video/mp4\">\n  Your browser does not support the video tag. Have a look at the screenshot examples below.\n</video>\n\n\n\n<details>\n  <summary><strong>Expand to see HTML rendering of transformation steps</strong></summary>\n\n<pre style=\"font-family:consolas,monospace\">\n<span style=\"color:#880000\">------ </span><span style=\"font-weight:bold\">000.step 2021-03-26 04:50:53.499923-04:00</span>\n<span style=\"color:#008800\">++++++ </span><span style=\"font-weight:bold\">001.step 2021-03-26 04:50:54.572018-04:00</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\">@|</span></span><span style=\"font-weight:bold\">-1,16 +1,16</span> ============================================================\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>const BitField = packed struct {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            a: u3,\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            b: u3,\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            c: u2,\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        };\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn foo(error.Hi) u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>            return bar(<span style=\"color:#880000\">&amp;bit_field.b</span>);\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn bar(x: *const u3) u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            return x.*;\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n</pre>\n<pre style=\"font-family:consolas,monospace\">\n<span style=\"color:#880000\">------ </span><span style=\"font-weight:bold\">001.step 2021-03-26 04:50:54.572018-04:00</span>\n<span style=\"color:#008800\">++++++ </span><span style=\"font-weight:bold\">002.step 2021-03-26 04:50:55.616110-04:00</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\">@|</span></span><span style=\"font-weight:bold\">-1,16 +1,16</span> ============================================================\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>const BitField = packed struct {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            a: u3,\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            b: u3,\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            c: u2,\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        };\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn foo(error.Hi) u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            return bar();\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>        fn bar(<span style=\"color:#880000\">x: *const u3</span>) u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            return x.*;\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n</pre>\n<pre style=\"font-family:consolas,monospace\">\n<span style=\"color:#880000\">------ </span><span style=\"font-weight:bold\">002.step 2021-03-26 04:50:55.616110-04:00</span>\n<span style=\"color:#008800\">++++++ </span><span style=\"font-weight:bold\">003.step 2021-03-26 04:50:57.132244-04:00</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\">@|</span></span><span style=\"font-weight:bold\">-1,16 +1,12</span> ============================================================\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>const BitField = packed struct {\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span><span style=\"color:#880000\">            a: u3,</span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span><span style=\"color:#880000\">            b: u3,</span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span><span style=\"color:#880000\">            c: u2,</span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>        };\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn foo(error.Hi) u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            return bar();\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn bar() u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            return x.*;\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n</pre>\n<pre style=\"font-family:consolas,monospace\">\n<span style=\"color:#880000\">------ </span><span style=\"font-weight:bold\">003.step 2021-03-26 04:50:57.132244-04:00</span>\n<span style=\"color:#008800\">++++++ </span><span style=\"font-weight:bold\">004.step 2021-03-26 04:50:57.748298-04:00</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\">@|</span></span><span style=\"font-weight:bold\">-1,12 +1,10</span> ============================================================\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>const BitField = packed struct {};\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>        fn foo(error.Hi) u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span><span style=\"color:#880000\">            return bar();</span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn bar() u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>            return x.*;\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n</pre>\n<pre style=\"font-family:consolas,monospace\">\n<span style=\"color:#880000\">------ </span><span style=\"font-weight:bold\">004.step 2021-03-26 04:50:57.748298-04:00</span>\n<span style=\"color:#008800\">++++++ </span><span style=\"font-weight:bold\">005.step 2021-03-26 04:50:58.356352-04:00</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\">@|</span></span><span style=\"font-weight:bold\">-1,10 +1,8</span> ============================================================\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>const BitField = packed struct {};\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn foo(error.Hi) u3 {}\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>        fn bar() u3 {\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span><span style=\"color:#880000\">            return x.*;</span>\n<span style=\"color:#000000\"><span style=\"background-color:#888800\">!|</span></span>        }\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n</pre>\n<pre style=\"font-family:consolas,monospace\">\n<span style=\"color:#880000\">------ </span><span style=\"font-weight:bold\">005.step 2021-03-26 04:50:58.356352-04:00</span>\n<span style=\"color:#008800\">++++++ </span><span style=\"font-weight:bold\">006.step 2021-03-26 04:50:59.464450-04:00</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\">@|</span></span><span style=\"font-weight:bold\">-1,8 +1,6</span> ============================================================\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>const BitField = packed struct {};\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn foo(error.Hi) u3 {}\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#880000\">-|</span></span><span style=\"color:#880000\">        fn bar() u3 {}</span>\n<span style=\"color:#000000\"><span style=\"background-color:#880000\">-|</span></span><span style=\"color:#880000\">        </span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n</pre>\n<pre style=\"font-family:consolas,monospace\">\n<span style=\"color:#880000\">------ </span><span style=\"font-weight:bold\">007.step 2021-03-26 04:51:01.000586-04:00</span>\n<span style=\"color:#008800\">++++++ </span><span style=\"font-weight:bold\">008.step 2021-03-26 04:51:01.596638-04:00</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\">@|</span></span><span style=\"font-weight:bold\">-1,5 +1,4</span> ============================================================\n<span style=\"color:#000000\"><span style=\"background-color:#880000\">-|</span></span><span style=\"color:#880000\">const BitField = packed struct {};</span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        fn foo(error.Hi) u3 {}\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>\n<span style=\"color:#000000\"><span style=\"background-color:#c0c0c0\"> |</span></span>        export fn entry() usize { return @sizeOf(@TypeOf(foo)); }\n</pre>\n\n</details>\n\nYou can [find out more about replaying in the repo](https://github.com/comby-tools/comby-reducer#comby-reducer-replay).\n\n\n## Comparison to `afl-tmin`\n\nIt's useful to compare some reduction to\n[`afl-tmin`](https://github.com/google/AFL/blob/master/docs/technical_details.txt#L281-L313),\nwhich is a readily-available reducer for our afl-instrumented Solidity and Move\ncompilers. Because `afl-tmin` exploits coverage information, it can be very\neffective at minimizing the size of inputs irrespective of format (it works for\ntext inputs like our crashing programs, and binary formats like JPEG). At the\nsame time, this catch-all coverage-guided approach sacrifices some ability to\nexploit properties of the input domain. For bug reports, it's useful to reduce\naround certain syntax like parentheses, or otherwise preserve syntactic\nelements, formatting, or symbol names. `comby-reducer` makes it easy to tailor\nthe process around the input. For example, the reduced Move program by\n`comby-reducer` gives\n\n```rust\nmodule M {\n    resource struct R {}\n    fun t0() {\n        R = ();\n    }\n}\n```\n\nwhile `afl-tmin` gives\n\n\n```rust\nmodule M{resource struct R{}struct C{}fun t(x:u){();();();R=();()}}\n```\n\nThe `afl-tmin` variety has some redundant syntax, eagerly deletes whitespace\nthat help with readability, and renames the original function `t0` to `t`. These\nare not necessarily bad, but there isn't much room for tweaking.\n\nAnother example produced by `comby-reduce`\n\n```rust\nmodule M {\n    struct Box3<T1, T2, T3> {}\n    fun cpy<C: copyable>() {}\n    fun t3<U, C: copyable>() {\n        cpy(Box3<U, U> {});\n    }\n}\n```\n\nversus `afl-tmin`:\n\n```rust\nmodule M{struct S{}resource struct C{}struct o{}struct Bo00<>{}fun h(r:R){}fun y(r:R){}fun t(){}fun t<>(){}fun t(){();(Bo00<U>{})}}\n```\n\n<details>\n  <summary><strong>Original program for the above reductions</strong></summary>\n\n  ```rust\nmodule M {\n    struct S {}\n    resource struct Coin {}\n    struct Box<T> {}\n    struct Box3<T1, T2, T3> {}\n\n    fun both<R: resource, C: copyable>(r: R, c: C) {\n        abort 0\n    }\n\n    fun cpy<C: copyable>(c: C) {\n        abort 0\n    }\n\n    fun rsrc<R: resource>(r: R) {\n        abort 0\n    }\n\n\n    fun t0() {\n        both(S{}, Coin{});\n        both(0, Coin{})\n    }\n\n    fun t1<R: resource, C: copyable>() {\n        both(Box<C> {}, Box<R> {})\n    }\n\n    fun t2<R: resource, C: copyable>() {\n        rsrc(Box3<C, C, C> {});\n\n        cpy(Box3<R, C, C> {});\n        cpy(Box3<C, R, C> {});\n        cpy(Box3<C, C, R> {});\n\n        cpy(Box3<C, R, R> {});\n        cpy(Box3<R, C, R> {});\n        cpy(Box3<R, R, C> {});\n\n        cpy(Box3<R, R, R> {});\n    }\n\n    fun t3<U, C: copyable>() {\n        cpy(Box3<U, C, C> {});\n        cpy(Box3<C, U, C> {});\n        cpy(Box3<C, C, U> {});\n\n        cpy(Box3<C, U, U> {});\n        cpy( C,Box3<U, U> {});\n        cpy(Box3<U, U, C> {});\n\n        cpy(Box3<U, U, U> {});\n    }\n}\n  ```\n\n</details>\n\n## Try it\n\nSee the [GitHub repository](https://github.com/comby-tools/comby-reducer) for\nusage examples and more technical details. Note that `comby-reducer` is new,\ndeveloped with simplicity, and not yet very battle tested; feel free to post\nissues in the GitHub issue tracker. If you want help writing\ntransformations `comby` syntax, post in the [Gitter channel](https://gitter.im/comby-tools/community).\n\n## Learn more\n\nThere are a lot of reducer tools and techniques out there. The academic in me\nwould love to explore and compare these more deeply, but the engineer in me\ndoesn't have the time. 🙂\n\nSo instead, here are some related tools and topics that you might want to\nexplore further.\n\n- The [Reducing chapter](https://www.fuzzingbook.org/html/Reducer.html) in The\nFuzzing Book provides a deeper explanation of reducers, and particularly [grammar-based reduction](https://www.fuzzingbook.org/html/Reducer.html#Grammar-Based-Input-Reduction). Here `comby-reducer` can be seen as a coarse, syntax-only\ngrammar-based reducer that doesn't need you to write or understand the grammar,\nnor write any scripts or visitors to hook into a parse tree. Instead,\ntransformations are specified declaratively and appeal to intuitive notions\naround syntax common to many languages.\n\n- This deep-dive [article on test-case reduction](https://blog.trailofbits.com/2019/11/11/test-case-reduction/)\nincluding various references to existing tools.\n\n- A favorite tool mentioned here is [C-reduce](https://github.com/csmith-project/creduce)\n(which also works well on non-C languages). It is an especially nice resource\nfor explaining [interestingness tests](https://embed.cs.utah.edu/creduce/using/)\nwhich can further guide how and when the input is transformed."
    },
    {
      "id": "/2020/06/10/new-blog-site",
      "metadata": {
        "permalink": "/blog/2020/06/10/new-blog-site",
        "source": "@site/blog/2020-06-10-new-blog-site.md",
        "title": "Comby website gets a refresh",
        "description": "The old website started off nice and simple and kept everything about",
        "date": "2020-06-10T00:00:00.000Z",
        "formattedDate": "June 10, 2020",
        "tags": [],
        "readingTime": 0.485,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Rijnard",
            "url": "https://twitter.com/rvtond",
            "imageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
          }
        ],
        "frontMatter": {
          "id": "new-blog-site",
          "title": "Comby website gets a refresh",
          "author": "Rijnard",
          "authorURL": "https://twitter.com/rvtond",
          "authorImageURL": "https://pbs.twimg.com/profile_images/1668091943950364675/ok0uhR3s_400x400.jpg"
        },
        "prevItem": {
          "title": "A simple program reducer for any language",
          "permalink": "/blog/2021/03/26/comby-reducer"
        }
      },
      "content": "The [old website](https://old.comby.dev) started off nice and simple and kept everything about\n`comby` on one page. As that grew things being unwieldly, and I wanted to\npartition off the usage documentation and \"other things\". Another piece of\nfeedback was that the landing page wasn't working for some (\"what is this\nthing?\").\n\nSo over the past couple of weeks I've been building a new site piece by piece. I\nthink the result gets rid of a couple of thorns and I like the refresh. I was\ninspired by the [Sorbet website](https://sorbet.org/) and ended up using\n[Docusaurus](https://docusaurus.io/), it's cool."
    }
  ]
}